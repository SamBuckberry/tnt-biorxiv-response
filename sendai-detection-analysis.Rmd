---
title: "RNA-seq re-analysis: MEL1 reprogramming system"
author: "Sam Buckberry"
date: "`r Sys.Date()`"
output: 
  html_document:
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, warning=FALSE, error=FALSE}
source("project-functions.R")
```

## Background
De Los Angeles et al. state "Surprisingly, control MEL1 hESC samples from Buckberry et al. also had low but detectable levels of Sendai expression" and "hESCs were not deliberately infected with Sendai viruses, suggesting a contamination or possibly a mix-up of hESC and TNT hiPSC samples."

Presented here is a re-analysis of the RNA-seq data from the MEL1 isogenic control experiments from Buckberry et al. (Figure 4). 

The aim of this study is to evalulate the detection and quantificaiton of Sendai virus (SeV) genes in MEL1 ESC, fibroblast, primed, NtP and TNT samples. 

## Methods

### polyA RNA-seq (as reported in Buckberry et al. 2023 Nature)
RNA was extracted using the Agencourt RNAdvance Cell v2 (Beckman Coulter) system following the manufacturer’s instruction with one additional DNAse (NEB) treatment step. RNA amounts and RINe scores were assessed on a TapeStation using RNA Screen Tape (Agilent), and 500 ng of total RNA were used per sample to generate RNA-seq libraries. **ERCC ExFold RNA Spike-In mixes (Thermo Scientific) were added as internal controls**. Libraries were prepared using the TruSeq Stranded mRNA library prep kit (Illumina), using TruSeq RNA unique dual index adapters (Illumina). Libraries were quantified by qPCR on a CFX96/C1000 cycler (Bio-Rad), **multiplexed and sequenced on a NovaSeq 6000 (Illumina)** in 2× 53-bp paired-end format.

### Pre-map filtering
FASTQ files were processed with `fastp` with the options `--detect_adapter_for_pe --trim_poly_g --trim_front1 1 --trim_tail1 1 --correction`

### Reference genomes and alignment
Reference genomes GRCh38, NC_075392.1 and ERCC spike in sequences, along with gencode v27 primary assembly annotations, transposable element annotations, and sendai gene models were used to create a STAR alignment index.  

Reads were aligned with the STAR default options.  

Post-alignment BAM files were filtered for unique alignments using `samtools -q 255` as STAR uses the MAPQ score of 255 to mark unique alignments. PCR duplicates were marked with `samtools markdup`. 

### Expression quantification
Given the goal is _confident_ virus detection, a conservative approach has been taken to assigning reads to features. These features include gencode genes, transposable elements, SeV genes and ERCC spike in transcripts. 

Quantification was performed with featureCounts with the options `featureCounts -p -T 16 -s 2 --fracOverlap 0.75 --primary --ignoreDup --countReadPairs -B -C -a`.

**This conservative approach only counts reads that are [1] primary alignments (actually already filtered for with unique alignments), [2] not PCR or optical/exAmp duplicates, [3] both pairs are mapped and not discordant, and [4] reads that overlap the feature being counted by at least 75%.** 

## Results
```{r, cache=TRUE, message=FALSE, warning=FALSE}
## Sample metadata
sample_dat <- data.table::fread("polyA_RNAseq_sample_table.tsv")

## RNA-seq counts data
count_dat <- read.table("mel1_rmdup.featureCounts.gz", header = TRUE)
colnames(count_dat) <- colnames(count_dat) %>%
    str_remove("X.data.tki_bodl.sammyb.") %>%
    str_remove("_Aligned.markdup.bam")

## Subset just to counts
dat <- count_dat[ ,colnames(count_dat) %in% sample_dat$Library]
rownames(dat) <- count_dat$Geneid

# Check library ID's match and order accordingly
stopifnot(all(colnames(dat) %in% sample_dat$Library))
sample_dat <- sample_dat[match(colnames(dat), sample_dat$Library), ]
stopifnot(all(sample_dat$Library == colnames(dat)))

## Load the ERCC data
ercc_metrics <- read.csv("ERCC_controls_metrics.csv")
ercc_metrics$dilution <- 1/1000
ercc_metrics$spike_vol_ul <- 4
ercc_metrics$totalRNAmass <- 0.2

## Load the sendai gene data
library(rtracklayer)
sendai <- readGFF(filepath = "NC_075392.1.gff3")
sendai_dat <- data.frame(chr=sendai$seqid, type=sendai$type, id=sendai$ID,
                         gene=sendai$gene, start=sendai$start, end=sendai$end)

# Calculate TPM
countToTpm <- function(counts, effLen){
    rate <- log(counts) - log(effLen)
    denom <- log(sum(exp(rate)))
    exp(rate - denom + log(1e6))
}

tpm <- countToTpm(counts = dat, effLen = count_dat$Length)

ercc_tpm <- tpm
ercc_tpm$ercc <- rownames(ercc_tpm)
ercc_tpm <- ercc_tpm[rownames(ercc_tpm) %in% ercc_metrics$ERCC, ]
ercc_tpm <- melt(ercc_tpm)

ercc_tpm$molecules_ul_mix1 <- ercc_metrics$molecules.ul.mix.1[match(ercc_tpm$ercc, ercc_metrics$ERCC)]
ercc_tpm$molecules_ul_mix2 <- ercc_metrics$molecules_ul_mix2[match(ercc_tpm$ercc, ercc_metrics$ERCC)]
ercc_tpm$mix <- factor(sample_dat$ERCC_Spike[match(ercc_tpm$variable, sample_dat$Library)])
ercc_tpm$conc <- ifelse(ercc_tpm$mix == "Mix1",
                        yes = ercc_tpm$molecules_ul_mix1,
                        no = ercc_tpm$molecules_ul_mix2)
ercc_tpm$transcripts <- ((ercc_tpm$conc / (1/1000))*4)/200

## Get the sendai expression data
sendai_genes <- count_dat$Geneid[count_dat$Chr ==  "NC_075392.1"]
sendai_tpm <- tpm[rownames(tpm) %in% sendai_genes, ]
sendai_tpm$id<- rownames(tpm)[rownames(tpm) %in% sendai_genes]
sendai_tpm <- reshape2::melt(sendai_tpm)
sendai_tpm$gene_id <- sendai_dat$gene[match(sendai_tpm$id, sendai_dat$id)]
sendai_tpm$group <- sample_dat$Group[match(sendai_tpm$variable, sample_dat$Library)]
sendai_tpm$gene_id <- factor(sendai_tpm$gene_id, levels=unique(sendai_dat$gene))
sendai_tpm$ercc_mix <- sample_dat$ERCC_Spike[match(sendai_tpm$variable, sample_dat$Library)]
```

#### Sample information

**Table 1:** Sample metadata.  

```{r, cache=TRUE, message=FALSE, warning=FALSE, error=FALSE}
knitr::kable(sample_dat, booktabs = TRUE, latex_options = "scale_down") %>%
  kableExtra::kable_styling()
```


#### RNA fragment assignment metrics

**Table 2:** Number of RNA-seq fragments assigned to major feature classes.   

```{r, cache=TRUE}
### Count proportion of reads mapping to each feature type

## TE's. Annotation from Hammell lab
te_gr <- import("GRCh38_GENCODE_rmsk_TE.gtf.gz", format = "gtf")

## Gencode genes
gene_gr <- import("gencode.v27.primary_assembly.annotation.gtf.gz", format = "gtf")

## Sendai genes

## ERCC spike ins
ercc_gr <- import("ERCC92.gtf", format = "gtf")

## Count reads assigned to each feature type for each library
total_counts <- colSums(dat)
sendai_count <- colSums(dat[rownames(dat) %in% sendai_genes, ])
te_count <- colSums(dat[rownames(dat) %in% te_gr$gene_id, ])
gencode_count <- colSums(dat[rownames(dat) %in% gene_gr$gene_id, ])
ercc_count <- colSums(dat[rownames(dat) %in% ercc_gr$gene_id, ])

count_sum_df <- data.frame(Total = total_counts, Gencode_genes = gencode_count,
                           TE_count = te_count, ERCC_count = ercc_count,
                           Sendai_count = sendai_count)

count_pc_df <- (count_sum_df[ ,-1] / count_sum_df$Total)*100

count_pc_df$Sendai_count <- format(round(count_pc_df$Sendai_count, digits = 5),
                                   scientific = FALSE, nsmall = 5) %>% as.numeric()

count_pc_df[ ,1:3] <- round(count_pc_df[ ,1:3], digits = 2)

count_pc_df[] <- lapply(count_pc_df, function(x) {
  if (is.numeric(x)) {
    format(x, scientific = FALSE)  # Prevent scientific notation
  } else {
    as.character(x)  # Convert non-numeric columns to character
  }
})

# Convert all columns to character with commas as thousands separators
count_sum_df[] <- lapply(count_sum_df, function(x) format(x, big.mark = ",",
                                                          scientific = FALSE))


df_concat <- mapply(function(x, y) paste0(x, " (", y, "%)"),
                    count_sum_df[ ,-1], count_pc_df, SIMPLIFY = TRUE) %>%
    data.frame()

summary_table <- data.frame(Library=sample_dat$Library, Group=sample_dat$Group,
              Passage = sample_dat$Passage, reads = count_sum_df$Total, df_concat)

colnames(summary_table)[4:8] <- c("Total assigned fragments", "Gencode genes", "Transposable elements", "ERCC controls", "Sendai virus genes" )

## Clean up
summary_table$Group <- str_replace(string = summary_table$Group, pattern = "N2P",
                                   replacement = "NtP")

summary_table <- summary_table[order(summary_table$Group), ]

knitr::kable(summary_table[ ,-3], booktabs = TRUE, latex_options = "scale_down", row.names = FALSE) %>%
  kableExtra::kable_styling()

```

#### Initial observations
- SeV genes for ESC's (primed) have <0.003% of reads for both samples.  
- SeV genes for Naive iPSCs have ~0.7% reads. 
- Naive iPSC's have >200 fold higher reads compared to ESC's confidently assigned to SeV genes.  

### ERCC spike-in controls

All libraries were spiked with ERCC control RNA transcripts. 

[ERCC (External RNA Controls Consortium) spike-in controls](https://www.thermofisher.com/order/catalog/product/4456740) are synthetic RNA molecules that are added to RNA-seq experiments to provide a set of known reference points. These controls consist of a mixture of RNA sequences of known concentration and sequence, which are not found in the sample's natural RNA population. The main purposes of using ERCC spike-ins include quality control, normalization, and the assessment of technical variability across RNA-seq experiments.

**ERCC concentrations and linear Range**. 
The linear range of an RNA-seq assay is the range of concentrations over which the assay can accurately and linearly quantify RNA abundance. By analysing the relationship between the known concentrations of ERCC spike-ins and their measured expression levels (e.g. TPM), one can assess the linearity of the assay. **Ideally, there should be a linear relationship between the log-transformed known concentrations and the log-transformed measured expression levels (TPM) for the spike-ins. Deviations from linearity, especially at very low concentrations, can indicate the lower bounds of the assay's linear dynamic range.** Within the linear range, I would consider the quantification of RNA to be reliable and proportional to the actual abundance.

ERCCs come in two mixes, and in this study, seven of the samples were spiked with mix_1 and five with mix_2.

The plot below shows the relationship between the known RNA concentration and the estimated transcript abundance (both log2 scale).  

```{r, cache=TRUE, message=FALSE, warning=FALSE, error=FALSE}

gg <- ggplot(ercc_tpm, aes(x = log2(conc), y = log2(value+1), colour=mix)) +
    facet_wrap(.~mix) +
    geom_point(alpha=0.5) +
    geom_smooth(method = "loess", colour="black", se = FALSE, size=1) +
    #geom_smooth(method = "lm", colour="red", se =TRUE, size=1) +
    scale_y_continuous(limits = c(0,10)) +
    xlab("ERCC transcript conc. (Log2 attomoles/ul)") +
    ylab("Detected TPM (Log2 TPM+1)") +
    theme_bw() +
    #geom_vline(xintercept = 17.5, linetype="dashed") +
    theme(legend.position = "none") 
gg
```

**Figure 1:** ERCC transcript quantification in relation to known concentrations with loess curve. **Note that the relationship between transcript concentration and TPM does not become linear until greater than ~17.5 on the x-axis, and transcript concentrations <15 log2 attomoles/ul would be challenging to detect.**

Next, let's plot the linear model for RNA concentration values >log2(17).  

```{r, cache=TRUE, message=FALSE, warning=FALSE, error=FALSE}

## Group data by 'mix' for lm fit
ercc_tpm_grouped <- ercc_tpm %>%
  group_by(mix)

## Filter, fit models, and calculate R2 for each mix
models <- ercc_tpm_grouped %>%
  do({
    filtered <- filter(., log2(conc) > 17)
    model <- lm(log2(value + 1) ~ log2(conc), data = filtered)
    data.frame(mix = unique(.$mix), R2 = summary(model)$r.squared)
  })

## Plot with separate linear models for each 'mix'
gg <- ggplot(ercc_tpm, aes(x = log2(conc), y = log2(value + 1), colour = mix)) +
  facet_wrap(. ~ mix) +
  geom_point(alpha = 0.5) +
  geom_smooth(data = subset(ercc_tpm, log2(conc) > 17), aes(group = mix),
              method = "lm", colour = "black", se = TRUE, size = 1) +
  scale_y_continuous(limits = c(0, 10)) +
  xlab("ERCC transcript conc. (Log2 attomoles/ul)") +
  ylab("Detected TPM (Log2 TPM+1)") +
  theme_bw() +
  geom_vline(xintercept = 17, linetype = "dashed") +
  theme(legend.position = "none")
gg


```

**Figure 2:** ERCC transcript quantification in relation to known concentrations with linear model for transcript concentration values above 17.

We can also calculate the standard deviation of log2 TPM estimates for RNA concentration ranges to visualise how much error we expect in TPM estimates.  

```{r, cache=TRUE, message=FALSE, warning=FALSE, error=FALSE}

ercc_tpm_sub <- ercc_tpm[log2(ercc_tpm$conc) > 17, ]
ercc_tpm_sub$log2_conc <- log2(ercc_tpm_sub$conc)
    
## Bin y-axis values and calculate standard deviation within each bin
bin_width <- 1 # Define the bin width for Log2(TPM+1)
ercc_tpm_sub$bin <- cut(ercc_tpm_sub$log2_conc,
                        breaks=seq(floor(min(ercc_tpm_sub$log2_conc)),
                                   ceiling(max(ercc_tpm_sub$log2_conc)),
                                   by=bin_width),
                        include.lowest = TRUE, labels = FALSE)



# Calculate mean RNA concentration and standard deviation within each bin
std_dev_df <- ercc_tpm_sub %>%
    group_by(bin) %>%
    summarise(mean_conc = floor(mean(log2_conc)),
                  std_dev = sd(log2(value)))

# Plotting
gg_std_dev <- ggplot(std_dev_df, aes(x = mean_conc, y = std_dev)) +
    geom_point(size=2, alpha=0.75) +
    geom_smooth(method = "loess", se = FALSE) +
    geom_hline(yintercept = 1, linetype="dashed") +
    geom_vline(xintercept = 22.5, linetype="dashed") +
    scale_x_continuous(breaks = seq(from = floor(min(std_dev_df$mean_conc)), 
                                  to = ceiling(max(std_dev_df$mean_conc)),
                                  by = 1)) +
    scale_y_continuous(breaks = seq(from = 0, 
                                  to = ceiling(max(std_dev_df$std_dev)),
                                  by = 0.2), limits = c(0, 1.5)) +
    xlab("ERCC transcript conc. (Log2 attomoles/ul)") +
    ylab("Standard Deviation of Log2 TPM+1") +
    ggtitle("TPM standard deviation by RNA concentration") +
    theme_bw()

gg_std_dev
```

**Figure 3:** The relationship between known RNA concentration (x-axis) and log2 TPM standard deviation (y-axis) shows that standard deviation decreases below 1 when log2 RNA attomoles/ul > 22. **Note that a log2 TPM standard deviation of 1 indicates a doubling (on the upper-bound) and halving (on the lower-bound).** 

#### ERCC quantification observations 
- The expected linear relationship between log2 RNA concentrations and Log2 TPM values does not occur until log2 RNA concentrations are >17 attomoles/ul.  
- TPM variance, as measured by log2 TPM standard deviation, is >1 for log2 RNA concentrations < 22.  
- Given that log2 TPM standard deviation of 1 indicates a doubling (on the upper-bound) and halving (on the lower-bound), and that standard deviations are >1 for log2 RNA concentrations < 22, TPM is an unreliable estimate of true expression at these low levels.  

---

### Sendai (SeV) expression
The CytoTune 2.0 iPSC Sendai Reprogramming Kit is designed for the efficient generation of iPSCs from somatic cells. This kit employs a non-integrating Sendai virus (SeV) vector system to deliver key reprogramming factors into target cells, minimising the risk of genetic modifications to the host genome that can occur with integrating viral vectors. The Sendai virus is an RNA virus that does not enter the nucleus or integrate into the host DNA, making it an attractive tool for reprogramming applications where genomic integrity is a priority.

Typically, it is expected that the SeV vectors are gradually lost from the cells over time through cell division and passaging.

**The SeV genome contains 6 genes: NP, P, M, F, HN and L. The F gene is deleted in the CytoTune 2.0 kits.** 

```{r, cache=TRUE, message=FALSE, warning=FALSE, error=FALSE, fig.height=1.5, fig.width=6}

options(ucscChromosomeNames=FALSE)

# Import the GFF3 file
annotationPath <- "NC_075392.1.gff3"  # Make sure to use the correct path
annotations <- rtracklayer::import(annotationPath, format = "GFF3")
annotations <- annotations[annotations$type == "gene"]

# Create the GenomeAxisTrack
genomeAxisTrack <- GenomeAxisTrack()

# Create the AnnotationTrack with gene names

annotationTrack <- AnnotationTrack(range = annotations,
                                   name = "SeV",
                                   showFeatureName = TRUE,
                                   featureAnnotation = "gene",  # Use 'gene' if gene names are stored in the 'gene' attribute
                                   chromosome = "NC_075392.1")
annotationTrack@range$group <- annotations$gene
# Plot the tracks
plotTracks(list(genomeAxisTrack, annotationTrack), from = 1, to = 15384)
```

```{r, include = FALSE}
pdf("sendai-track.pdf", height = 1, width = 4)
plotTracks(list(genomeAxisTrack, annotationTrack), from = 1, to = 15384)
dev.off()


```


**Figure 4:** SeV gene model.

---

The following figures show the TPM estimates for SeV genes across all libraries in this experiment set, both for TPM and log2 transformed TPM values. 

```{r, cache=TRUE, message=FALSE, warning=FALSE, error=FALSE, fig.width=9, fig.height=4}

## Drop the F gene data and clean up
sendai_tpm <- sendai_tpm[sendai_tpm$gene_id != "F", ]
sendai_tpm$group[sendai_tpm$group == "N2P"] <- "NtP"

## Drop the fibroblast sample as not needed here forward
sendai_tpm <- sendai_tpm[sendai_tpm$group != "Fibroblast", ] 

reprog_pal <- c(Primed="#009E73", Naive="#0072B2",
                TNT="#EEBC4C", NtP="#55B3EA", ESC="darkgrey")

sendai_tpm$group <- factor(sendai_tpm$group, levels=names(reprog_pal))

gg_sendai2 <- ggplot(sendai_tpm, aes(x = group, y = value, colour=group)) +
    geom_point(size=2) +
    scale_colour_manual(values = reprog_pal) +
    facet_grid(.~gene_id) +
    ylab("Sendai gene TPM") + 
    #scale_y_continuous(limits = c(0,10)) + 
    theme_bw() +
    theme(axis.text.x.bottom = element_text(angle = 45, hjust = 1))

gg_sendai2

```

**Figure 5:** SeV gene expression in MEL1 ESC, fibroblast and iPSC samples expressed as transcripts per million (TPM). Each group has two samples.

```{r, cache=TRUE, message=FALSE, warning=FALSE, error=FALSE, fig.width=9, fig.height=4}
gg_sendai <- ggplot(sendai_tpm, aes(x = group, y = log2(value+1), colour=group)) +
    geom_point(size=2.5) +
    scale_colour_manual(values = reprog_pal) +
    facet_grid(.~gene_id) +
    ylab("Detected TPM (Log2 TPM+1)") + 
    scale_y_continuous(limits = c(0,10)) + 
    sams_pub_theme(legend_pos = "none") +
    theme(axis.text.x.bottom = element_text(angle = 45, hjust = 1))

gg_sendai
```



**Figure 6:** SeV gene expression as in Fig. 5 but on log2 scale. 

**Observations**.    
- SeV gene expression is clearly detectable in both Naive sample replicates across genes.  
- SeV gene expression is detected at relatively low levels for one NtP replicate.  
- SeV gene expression is detected at relatively low levels for one ESC replicate for NP, P, M, HN genes, and not detected for L gene.  
- As not all SeV genes were detected for NtP and ESC, it does question if this results from bona fide SeV expression in these cells.  In the case of ESC's, this warrants deeper investigation as these cells were not infected with SeV intentionally. 
- SeV expression in ESCs likely due to some contamination or otherwise given such low levels. 


```{r}
ercc_tpm$group <- "ERCC spike-in transcripts"

ercc_tpm <- ercc_tpm[ercc_tpm$variable %in% sendai_tpm$variable, ]

gg <- ggplot(ercc_tpm, aes(x = log2(conc), y = log2(value + 1))) +
  geom_point(alpha = 0.2, size=2.5, colour="#5B7876") +
    facet_grid(~group) +
  geom_smooth(data = subset(ercc_tpm, log2(conc) > 17),
              method = "lm", colour = "firebrick", se = TRUE, size = 1) +
  scale_y_continuous(limits = c(0, 10)) +
  xlab("ERCC transcript conc. (Log2 attomoles/ul)") +
  ylab(NULL) +
  sams_pub_theme(x.text.angle = 0, hjust = 0.5) +
  geom_vline(xintercept = 17, linetype = "dashed") +
  geom_hline(yintercept = log2(1+1), linetype = "dashed") +
  theme(legend.position = "none")

cp <- cowplot::plot_grid(plotlist = list(gg_sendai+ geom_hline(yintercept = log2(1+1), linetype = "dashed"), gg),nrow = 1,
                   align = "h", rel_widths = c(6,3))

cp
```

```{r, include=FALSE}
pdf("sendai-detection-ercc-comparison.pdf", height = 3, width = 8)
cp
dev.off()
```




---

### SeV expresssion in ESC's

De Los Angeles et al. claim "Surprisingly, control MEL1 hESC samples from Buckberry et al. also had low but detectable levels of Sendai expression" and "hESCs were not deliberately infected with Sendai viruses, suggesting a contamination or possibly a mix-up of hESC and TNT hiPSC samples."

It is clear in this analysis, that even with strict read filtering criteria after mapping, that some reads map to the SeV genome for ESC's. However, as we observed in Table 1, that the proportion of reads mapping to the SeV genome is relatively low, and arguably at levels much lower than one would expect for infected cells (i.e. Naive iPSCs).

**Library id's RL1966 and RL1967 correspond to ESC's with claimed contamination, as ESC's were not part of reprogramming experiments**

**Table 3:** Quantification of SeV genes in ESC's that were not experimentally infected with SeV.

```{r, cache=TRUE, message=FALSE, warning=FALSE, error=FALSE}

sendai_esc <- sendai_dat[sendai_dat$type == "gene", ]
sendai_esc$length <- count_dat$Length[match(sendai_esc$id, count_dat$Geneid)]

ind <- match(sendai_esc$id, count_dat$Geneid)

sendai_counts <- count_dat[ind, c("RL1966", "RL1967")]
colnames(sendai_counts) <- str_c(colnames(sendai_counts), "_total_read_counts")

esc_tpm <- round(tpm[(rownames(tpm) %in% sendai_esc$id), c("RL1966", "RL1967")], digits = 3)

colnames(esc_tpm) <- str_c(colnames(esc_tpm), "_TPM")

sendai_esc <- cbind(sendai_esc[ ,-c(1,2,3,5,6)], sendai_counts, esc_tpm)

rownames(sendai_esc) <- NULL
colnames(sendai_esc)[1:2] <- c("SeV gene", "Gene length")

knitr::kable(sendai_esc, booktabs = TRUE, latex_options = "scale_down", ) %>%
  kableExtra::kable_styling()
```

As we have ERCC spike-in RNA's for these libraries, we can assess where SeV gene expression fits within the range of quantifiable expression.

The following plots show the relationship between known ERCC spike in concentrations and TPM estimates only for the ESC samples, and the SeV TPM estimates. Thus, we are comparing only to 'internal' controls for these libraries. 
 
As we can calculate an internally-controlled linear model for the relationship between emperical RNA concentration and TPM estimates for each library, we can extrapolate and estimate what the RNA concentration would be from the linear models. 

Thus, with the linear model `lm(y~x)`, we can predict RNA concentration from a given TPM value, that is specific to each library based on interal controls with a _known_ dynamic range.  

```{r, cache=TRUE, message=FALSE, warning=FALSE, error=FALSE}

predict_sendai_rna_conc <- function(lib_id, lm_cut=17.5){
    
    ## Calculate the linear model for ERCC conc
    ## Subset the data where log2(conc) > 17.5 and mix = 1
    ercc_subset <- subset(ercc_tpm, variable == lib_id & log2(conc) > lm_cut)

    ## Fit the linear model
    model <- lm(log2(value + 1) ~ log2(conc), data = ercc_subset)

    ## extract model coefficients
    coefficients <- coef(model)
    intercept <- coefficients[1]  # Intercept of the model
    slope <- coefficients[2]      # Slope of the model
    
    ## Predict X for a Given Y
    ## Given a y value (i.e., log2(TPM + 1)), you can rearrange the linear equation y = slope * x + intercept to solve for x:
    predict_x <- function(y, slope, intercept) {
      x <- (y - intercept) / slope
      return(x)
    }
    
    ## Subset the sendai data for the specified library
    sendai_tpm_sub <- sendai_tpm[sendai_tpm$variable == lib_id, ]
    
    sendai_tpm_sub$RNA_conc <- lapply(X = log2(sendai_tpm_sub$value+1),
                                      FUN = predict_x,
                                      slope = slope,
                                      intercept = intercept) %>% unlist()
    out <- sendai_tpm_sub[ ,c("variable", "group", "gene_id", "value", "RNA_conc")]
    colnames(out) <- c("Library", "Group", "SeV gene", "TPM", "Est. RNA conc.")
    return(out)
}
    
plot_sendai_rna_predictions <- function(lib_id, lm_cut=17.5){
    
    ## Calculate the linear model for ERCC conc
    ## Subset the data where log2(conc) > 17.5 and mix = 1
    ercc_subset <- subset(ercc_tpm, variable == lib_id & log2(conc) > lm_cut)

    ## Fit the linear model
    model <- lm(log2(value + 1) ~ log2(conc), data = ercc_subset)

    ## extract model coefficients
    coefficients <- coef(model)
    intercept <- coefficients[1]  # Intercept of the model
    slope <- coefficients[2]      # Slope of the model
    
    ## Predict X for a Given Y
    ## Given a y value (i.e., log2(TPM + 1)), you can rearrange the linear equation y = slope * x + intercept to solve for x:
    predict_x <- function(y, slope, intercept) {
      x <- (y - intercept) / slope
      return(x)
    }
    
    ## Subset the sendai data for the specified library
    sendai_tpm_sub <- sendai_tpm[sendai_tpm$variable == lib_id, ]
    
    sendai_tpm_sub$RNA_conc <- lapply(X = log2(sendai_tpm_sub$value+1),
                                      FUN = predict_x,
                                      slope = slope,
                                      intercept = intercept) %>% unlist()
    
    gg_sendai <- ggplot(sendai_tpm_sub,
                        aes(x = group, y = log2(value+1), colour=variable)) +
    geom_point(size=2, alpha=0.75) +
    geom_errorbar(aes(ymin = log2(value+1),
                      ymax = log2(value+1)),
                  width = 1, size=0.5, linetype="44") +  # Adding horizontal lines
    facet_grid(variable~gene_id) +
    ylab("SeV gene expression \n(Log2 TPM+1)") + 
    scale_y_continuous(limits = c(0,10)) + 
    theme_bw() +
    theme(axis.text.x.bottom = element_text(angle = 45, hjust = 1)) +
        xlab("")  +
    scale_color_brewer(palette = "Set1") +
    theme(legend.position = "none")
    
    gg_ercc <- ggplot(ercc_subset, aes(x = log2(conc),
                                       y = log2(value+1))) +
    geom_point(alpha=0.75, size=1) +
    facet_grid(variable~mix) +
    geom_abline(intercept = intercept, slope = slope,
                color = "blue", size = 0.5) +
    scale_y_continuous(limits = c(0,10)) +
    scale_x_continuous(limits = c(18, 29)) +
    xlab("ERCC transcript conc. \n(Log2 attomoles/ul)") +
    ylab("Estimated expression \n(Log2 TPM+1)") +
    theme_bw() +
    scale_x_continuous(breaks = seq(from = floor(min(log2(ercc_tpm_sub$conc))), 
                                  to = ceiling(max(log2(ercc_tpm_sub$conc))),
                                  by = 1)) +
    scale_color_brewer(palette = "Set1")

    gg_ercc <- gg_ercc + geom_segment(data = sendai_tpm_sub[sendai_tpm_sub$gene_id != "F", ],
                           aes(x = RNA_conc, xend = RNA_conc, y = 0, yend = log2(value+1)),
                  color = "red", size = 0.5, linetype="44")
    
    gg_ercc <- gg_ercc + geom_segment(data = sendai_tpm_sub[sendai_tpm_sub$gene_id != "F", ],
                           aes(x = RNA_conc, xend = 29, y = log2(value+1),
                           yend = log2(value+1)),
                  color = "red", size = 0.5, linetype="44") 

    cp <- cowplot::plot_grid(gg_ercc, gg_sendai, align = "h", axis = "b")
    
    return(cp)
}

```


```{r, cache=TRUE, message=FALSE, warning=FALSE, error=FALSE}
plot_sendai_rna_predictions(lib_id = "RL1966")
```

```{r}
plot_sendai_rna_predictions(lib_id = "RL1967")
```

```{r}
plot_sendai_rna_predictions(lib_id = "RL1970")
```

```{r}
plot_sendai_rna_predictions(lib_id = "RL1979")
```

**Figure 7:** ERCC concentration and TPM estimates (left) and SeV expression quantification (right) for ESC (RL1966) with claimed mix-up by De Los Angeles et al. Linear model on left plot is used to extrapolate the RNA concentrations of SeV genes based on TPM estimates (right plot). Dashed red lines show the interestions of TPM estimates (horizontal lines) for SeV genes, and RNA concentration estimates (vertical lines). 

**Table 4:** SeV gene TPM estimates with predicted RNA concentrations (log2 attomoles/ul). 

```{r, cache=TRUE, message=FALSE, warning=FALSE, error=FALSE}
RL1966_sendai_rna_conc <- predict_sendai_rna_conc(lib_id = "RL1966")

knitr::kable(RL1966_sendai_rna_conc, booktabs = TRUE, latex_options = "scale_down") %>%
  kableExtra::kable_styling()
```

We can now see that the RNA concentration predictions for the SeV genes are all below 22.5, which we observed in **Fig. 3** would have an expected standard deviation of ~1.3 

Thus, if we plot log2 SeV TPM values, with standard deviations of 1.3, we see that for all but the "M" gene for RL1966, have error bars that cross zero. We must also keep in mind that this is log scale. 

```{r, cache=TRUE, message=FALSE, warning=FALSE, error=FALSE}
gg_conc_est <- ggplot(RL1966_sendai_rna_conc,
                        aes(x = Library, y = log2(TPM+1))) +
    geom_point(size=2, alpha=0.75) +
    geom_errorbar(aes(ymin = log2(TPM+1) - 1.3,
                      ymax = log2(TPM+1) + 1.3),
                  width = 0.5, size=0.5) +  # Adding horizontal lines
    facet_grid(.~`SeV gene`, scales = "free", space = "free", drop = TRUE) +
    ylab("SeV gene expression (Log2 TPM+1)") + 
    scale_y_continuous(limits = c(-2, 10)) + 
    theme_bw() +
    theme(axis.text.x.bottom = element_text(angle = 45, hjust = 1)) +
        xlab("")  +
    scale_color_brewer(palette = "Set1") +
    theme(legend.position = "none")
gg_conc_est

```

**Figure 8:** SeV expression TPM estimates for ESC (RL1966) with claimed mix-up by De Los Angeles et al. Linear modelling on ERCC spike ins was used to extrapolate the RNA concentrations of SeV genes based on TPM estimates (Fig. 7, Table 4). Error bars show a standard deviation of 1.3 derived from the standard deviation expected for the predicted RNA concentrations (Fig. 3).  

## Preliminary conclusions 

Here, I have used ERCC spike ins to develop a linear model that can be used to predict RNA concentration from TPM values, and also developed standard deviation estimates for RNA concentration and thus TPM value ranges. With this information, we can then begin to develop an informed Limit of Detection (LOD).  

In a LOD analysis, if your standard deviations (SD) cross zero, it suggests high variability in your measurements, particularly around very low concentration levels. When dealing with such low concentrations, it's indeed possible that the true value could be zero or near-zero, indicating that the transcript might not be present or is present at levels too low to be confidently detected.  

Thus, just because RNA-seq fragments mapped to a gene, does not mean they were at a level where one could say that it is not due to some unknown error. Importantly, there are other explanations for _error_ apart from sample mix-up and SeV infection. 

**Statistical Considerations**: Standard deviations crossing zero imply that some measurements are negative, which often occurs with methods when the signal is near the background noise level. In such cases, it's crucial to carefully interpret these results, considering the inherent limitations and uncertainties of the measurement technique.

**Confidence in Detection**: In the context of LOD, a key goal is to determine the lowest concentration at which transcripts or genes can be reliably detected. If the variability around this point is large enough to include zero, it suggests that detections at this concentration are not reliable, and thus, you may not confidently claim the transcripts presence.

**Based on this analysis so far, I would not claim that SeV genes are confidently detectable in ESC's in this experiment.**


```{r}
ensg_select <- gene_gr$gene_id[gene_gr$gene_name %in% c("DNMT3L", "ZNF729", "CNR2", "TSPYL5")]

ensg_select <- gene_gr$gene_id[gene_gr$gene_name %in% c("NKX2-5")]


candidate_list <- c("SLFN13","SLC39A4","DNAJA4","NNAT","KLF8","OXCT1","NKX2-5","PKIB","PIWIL2","PXMP4","MAOA","C9orf64","ZNF667-AS1","LRRC61","ZNF667","PNMA3","ACOT4","NR1I2","PCDHGC3","DENND2D","ZNF471","FRG1B","CIDEB","PCDHA11","ZNF676","ZNF835","FAR2P2","ZNF248","MIR4458HG","TSPYL5","LOC400655","CALCB","CHMP1B2P","ZNF560","SVIL-AS1","CCDC125","TRIM4","DDX43","OOEP","CR1L","AMH","RGPD2","RGPD1","NEURL1","NAP1L5","LOC151174","CTSF","ZNF662","LYNX1")

candidate_ensg <- gene_gr$ensembl_gene_id[gene_gr$gene_name %in% candidate_list] %>% unique()

## GEt the candidates from Choi data
de_gene_candidate <- rownames(de_genes)

gene_gr$ensembl_gene_id <- sub("\\..*$", "", gene_gr$gene_id)
de_gene_candidate <- de_gene_candidate[de_gene_candidate %in% gene_gr$ensembl_gene_id]

plot_gene <- function(gene_id){

    ensg_select <- gene_gr$gene_id[gene_gr$ensembl_gene_id %in% gene_id] %>% unique()

    tpm_select <- tpm[rownames(tpm) %in% ensg_select, ]
    tpm_select$ENSG_id <- rownames(tpm_select)
    
    tpm_select <- reshape2::melt(tpm_select)
    ind <- match(tpm_select$variable, sample_dat$Library)
    tpm_select$group <- sample_dat$Group[ind]
    
    ind2 <- match(tpm_select$ENSG_id, gene_gr$gene_id)
    tpm_select$Gene <- gene_gr$ensembl_gene_id[ind2]
    
    gg_gene_select <- ggplot(tpm_select, aes(x = group, y = value)) +
        #stat_summary(fun = mean, geom = "bar", width = 0.2, alpha=0.5) +
        geom_point(size=2, alpha=0.5) +
        #geom_col(width = 0.1) +
        ggtitle(str_c("MEL1: ", gene_id)) +
        ylab("TPM") +
        sams_pub_theme()
    
    # gg_gene_select_log <- ggplot(tpm_select, aes(x = group, y = log2(value+1))) +
    #     geom_point() +
    #     #facet_grid(Gene~., scales = "free") + 
    #     ggtitle(str_c("MEL1: ", gene_id)) +
    #     ylab("Log2 TPM+1") +
    #     sams_pub_theme()
    
#cowplot::plot_grid(gg_gene_select, gg_gene_select_log)
    gg_gene_select

}

pdf("candidate-genes.pdf", height = 4)
lapply(X = de_gene_candidate, plot_gene)
dev.off()
```


```{r}
candidate_2 <- c("ENSG00000113209", "ENSG00000198105", "ENSG00000206159", "ENSG00000162777")
```


```{r}
dat2 <- readRDS("~/Documents/GitHub/tnt/RNAseq/hochedlinger_data/all_te_and_gene_counts.Rds")


sample_dat2 <- read.csv("~/Documents/GitHub/tnt/RNAseq/hochedlinger_data/sample_sheet.csv")
dat2 <- dat2[ ,colnames(dat2) %in% sample_dat2$secondary_sample_accession]

sample_dat2 <- sample_dat2[match(colnames(dat2), sample_dat2$secondary_sample_accession), ]

all(colnames(dat2) == sample_dat2$secondary_sample_accession)

repeat_gtf <- read.table("~/Documents/GitHub/hs-reprogram/resources/hg19_rmsk_TE.gtf.gz")

y2 <- DGEList(counts = dat2)
y2$samples <- cbind(y2$samples, sample_dat2)
#choi_cpm <- edgeR::cpm(y2)

background=c("HUES3", "HUES2")
groups=c("iPSC", "ESC")
dataset="data set: isogenic"

y_sub <- y2[ ,(y2$samples$Background %in% background) &
                     (y2$samples$Group %in% groups) &
                     (y2$samples$characteristics_ch1 == dataset)]

groups <- factor(paste(y_sub$samples$Group, y_sub$samples$Background, sep="_"))
design <- model.matrix(~0 + groups)
colnames(design) <- levels(groups)

y_sub <- y_sub[filterByExpr(y = y_sub, design = design), ]
y_sub <- calcNormFactors(y_sub)
y_sub <- estimateDisp(y_sub, design = design, robust = TRUE)

fit <- glmFit(y_sub, design)

# Define the contrast for iPSC vs ESC across both backgrounds
contrast <- makeContrasts(
  iPSC_vs_ESC = (iPSC_HUES2 + iPSC_HUES3)/2 - (ESC_HUES2 + ESC_HUES3)/2,
  levels=design
)

# Test for differential expression
lrt <- glmLRT(fit, contrast=contrast)

# Apply an FDR threshold, e.g., 0.05
de_genes <- topTags(lrt, n=Inf, p.value=0.05)
de_genes <- de_genes$table[de_genes$table$logFC > 2 & de_genes$table$FDR < 0.05, ]

cpm_dat <- cpm(y_sub)

y2 


plot_gene_choi <- function(gene_id){

    gene_sub <- cpm_dat[rownames(cpm_dat) %in% gene_id, ]

    gene_sub <- reshape2::melt(gene_sub)
    
    gene_sub$id <- rownames(gene_sub)
    
    gene_sub$group <- y_sub$samples$Group[match(gene_sub$id,
                                        y_sub$samples$secondary_sample_accession)]
    
    gene_sub$bg <- y_sub$samples$Background[match(gene_sub$id,
                                        y_sub$samples$secondary_sample_accession)]

    gg1 <- ggplot(data = gene_sub[gene_sub$bg == "HUES2", ],
                  mapping = aes(x = group, y = value)) + 
        #stat_summary(fun = mean, geom = "errorbar", width = 0.2, alpha=0.5) +
        geom_point(size=2, alpha=0.5) +
        ggtitle(str_c("HUES2: ", gene_id)) +
        ylab("CPM") +
        sams_pub_theme()
    
    gg2 <- ggplot(data = gene_sub[gene_sub$bg == "HUES3", ],
                  mapping = aes(x = group, y = value)) + 
        #stat_summary(fun = mean, geom = "errorbar", width = 0.2, alpha=0.5) +
        geom_point(size=2, alpha=0.5) + 
        ggtitle(str_c("HUES3: ", gene_id)) +
        ylab("CPM") +
        sams_pub_theme()
    
    return(list(gg1, gg2))
    
}

plot_all <- function(gene_id){
    mel1 <- plot_gene(gene_id)
    hues <- plot_gene_choi(gene_id)
    cowplot::plot_grid(mel1,
                       hues[[1]],
                       hues[[2]], nrow = 1, align = "h", axis = "b")
}

pdf("candidate-ips-genes.pdf", height = 4)
lapply(candidate_ensg, plot_all)
dev.off()

plot_all("ENSG00000136305")
```



### Session info
```{r}
sessionInfo()
```

